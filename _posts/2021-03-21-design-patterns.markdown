##通用设计原则

 - 隔离变化
   将不同变化频率的部分分开，限制变化的影响范围
 - 面向接口编程
   隐藏实现，避免与实现耦合
 - 组合优于继承
   继承破坏了封装
   
##DRY原则

将系统分为多个部分，不要重复代码，但也要避免从业务的角度去消除重复。

##SOLID原则

单一职责（关注点分离也类似，导致软件分层）、开闭原则、里氏替换、接口隔离、依赖倒置

##经典设计模式

###建造模式

 - 工厂方法：在父类中声明创建对象的方法，由子类来实现具体的创建
 - 抽象工厂：在工厂方法的基础上，创建一系列相关的对象
 - 建造者：解决具有大量参数的复杂对象创建问题

### 结构模式
 
 - 适配器：通过对象适配或者类适配，解决接口不兼容的问题。
 - 桥接：将一个大的类或者一堆相关类分割为抽象和具体实现两部分。
 - 组合：将一组对象组成树结构并当作单一对象处理
 - 装饰：通过包裹对象给对象增加新的行为（套娃）
 - 门面：给一个复杂子系统提供一个简单的访问接口
 - 享元：大量对象中的重复不变数据与可变数据分离，将不变部分共享。
 - 代理：以替换或占位的方式代理对另一个对象的访问，从而插入一些额外的操作
 
### 行为模式

 - 职责链：构造一组handlers，每个handler处理完后传给下一个处理
 - 命令：将操作及其所需要的数据封装在对象里进行传递，例如GUI程序的菜单按钮响应
 - 迭代器：将遍历元素的行为与容器分离
 - 中介：减少模块间的直接依赖，使它们都通过中介协作，中介通常就是包含这些模块的容器本身
 - 备忘录：由对象自己来提供快照的保存和恢复
 - 观察者模式：最简单的监听事件模式
 - 状态模式：分离根据状态而变化的行为，和策略模式有点像。唯一区别是，状态模式各个状态之间是互相感知的，并且可以转换，策略模式则互相独立，并由更上一层来负责策略的替换。
 - 策略模式：将行为或算法独立出来
 - 模板模式：父类定义算法的骨架，由子类来覆盖算法中的某些步骤
 - 访问者：把处理算法从数据结构中分离出来
 

